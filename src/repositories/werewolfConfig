werewolfConfigのAST（構文解析木を作る）
抽象である
とりあえず、足し引き変数if,switch,for,whileを作る
ここらへんはjavascriptを回らずともできるように作りたい
indexOfなども作りたいが、ここらへんは一度javascriptを回らせてもええかな

String,int,boolean,を使えるようにする型推論より型宣言の方が楽そうだし、俺が慣れてる
構文解析木を作る


別に既存の自己言語の製法にこだわる必要はない
一文字ずつ調べるというのは、そうだがtoken自体は連想配列のmapでよくない？
そしてインタプリタを作るんじゃなくて。javascriptが読めるようなコンパイラにするのが理想では？


JavaScriptコンパイラ計画で行きます
字句解析の途中まで完成...うっ

抽象構文木(ASTを作るのですが、既存のインタプリタ言語のASTにそこまでこだわる必要はない？（結局のところ評価はjavascriptに行うのだから）)
ただsystem_deleted()(jsの自由度を制限させる)などを制限させるそれと、WereWolfConfigの言語は復生できることが大前提、それとメンテナンス性はやっぱり欲しい　拡張性も
拡張性とメンテ性を意識しながらsystem_deleted()を実行させないように作る

変数宣言(ex:)
String a = 3 + b;
=>
  変数宣言
    |- a: "DeclareString"
    |- express: "3 + b"

変数代入(ex:)
  a = 3 + c;
  =>
    変数代入
    |- a: (すでに宣言されているか調べる)
    |- express: "3 + c"

式評価:

/*
LOWEST = 1,
EQUALS,      // ==
LESSGREATER, // >, <
SUM,         // +
PRODUCT,     // *
PREFIX,      // -x, !x
KAKO , //(), {}
CALL,        // myFunction(x)

*/

3 + b + ( c + 4 ) * 5 + 3
=>
  まずそのtokenの優先順位をつけていく
  1 4 1 4 7 1 4 1 7 6 1
  [7,7,6,4,4,4,4,1,1,1,1,1]が行動
  優先度が高いものから行動を始める
  7　=> "()"
  相方のかっこを見つけるかEOFまで処理を開始する
  相方のかっこがなければerr
  ()のAST
   |- 中身

  1414済6141
  6 => "*"
  左,右に存在しなければerr (端っこの位置にいればng)
  右はliteralInt　もしくは、変数宣言されているInt型
  *のAST
  |- 左literal
  |- 右literal

  1414済41
  4 => "+"
  *と同じerr
  右のliteralはStringでも可
  +のAST
  |-　左literal
  |-　右literal

  済4済41
  済41
  済
  すべてが済になればok, 1は一人しかいない時に無条件で1になる


  expressAST
  木構造に分けるが、親から分割権限を持つと、それ以降のものがブロック間（rightAndLeftASTでは例えば左と右にわかれる）
  で対象にするしかないのでその解決方法備忘録
  案1: X　保留
  しきり棒を配列の間で縛って最後に木構造を作ることで末端からつくることができる
  ex:
  a = (1 + 4 + 5/5) * 3
  express抽出:
  (1 + 4 + 5/5) * 3
  express分解:
  n = 1 ()処理
  1 + 4 + 5/5
  * 3
  n = 2 ()の中身を最初に処理
  1 + 4 +
  /
  |- 5
  |- 5
  n = 3 +の処理
  +
  | -  1
  | -  4

  案２:再帰的プログラミングを応用する
  末端に行って形付けば完成する目論見なら、
  同期している前提
  ルールに乗っ取って 分割処理　
  分割処理された左と右をくっつけてreturn する
  分割処理できないものはただちにreturn　する
  これで
  ex:親1~3,子1
  親1:分割処理 -> 親2群に命令
  親2群: 分割処理 -> 親3群に命令
  親3群: 分割処理　-> 子1群に命令
  子1群:　分割処理 -> 分割できる子供がいないので,return　
  親3群:　子1群がreturn されたので、ルールに乗っ取りくっつけて、 return
  親2群: 親3群がreturnされたので、ルールに乗っ取りくっつけて、return
  親1群: 親2群がreturn されたので、ルールに乗っ取りくっつけて、return

  親1群がそのままcreateASTやIdentifyに対応した木として扱えるようになっているはず、もしくはなっていなかったら
  もう一つexpressParentAST等作成し、整形できるようにする（ここを軸に呼び出し、expressASTという再帰てきなfunctionを実行）

  この構造は 優先度が低いものが一番うえに行く
  つまり通常左にあるものの方が優先度が高いが右にあるほど上に行きやすく、優先度が低いほど上に行きやすい世界
  そうなるとliteral値は別


  2020/1/13/月曜 07:14日記
  simpleast(厳密にはastではないが)は一行で処理しようとしたが、
  実際のastほど厳密にではないが、区間区間で再帰的な処理にはできるかも？lint処理を
  そっちの方が、astの考え方に近くて良いかも
